<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CDT Automation Test</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #0f0; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .status.ok { background: #0a3d0a; }
        .status.error { background: #5c1a1a; color: #f88; }
        .status.info { background: #1a2a4a; color: #8cf; }
        pre { white-space: pre-wrap; word-break: break-all; }
    </style>
</head>
<body>
    <h1>CDT Automation Test Page</h1>
    <div id="output"></div>

    <script>
        // Configuration - URLs for base and diff files
        const CONFIG = {
            baseUrl: "https://res-1.cdn.office.net/officeonline/x/s/hA6AAD58BAE0BE8D8__layouts/App_Scripts/EwaTS.js",
            diffUrl: "https://res-1.cdn.office.net/officeonline/x/s/hB48C2DD66AF1B8FC__layouts/App_Scripts/EwaTS.js",
            wscdtParam: "1" // CDT treatment group
        };

        const output = document.getElementById("output");

        function log(message, type = "info") {
            const div = document.createElement("div");
            div.className = `status ${type}`;
            div.innerHTML = `<pre>${typeof message === "string" ? message : JSON.stringify(message, null, 2)}</pre>`;
            output.appendChild(div);
        }

        function buildUrl(url) {
            return `${url}?wscdt=${CONFIG.wscdtParam}`;
        }

        // Output structured result to console for Playwright to capture
        function reportResult(result) {
            console.log("CDT_TEST_RESULT:" + JSON.stringify(result));
            log(result, result.status === "ok" ? "ok" : "error");
        }

        // Wait for Resource Timing entry to appear with complete data
        async function getResourceTimingEntry(url, retries = 20) {
            for (let attempt = 0; attempt < retries; attempt++) {
                const entries = performance.getEntriesByName(url, "resource");
                if (entries.length > 0) {
                    const entry = entries[entries.length - 1];
                    // Wait until responseEnd is set (indicates entry is complete)
                    // Note: For cross-origin requests without Timing-Allow-Origin,
                    // transferSize/encodedBodySize/decodedBodySize will be 0
                    if (entry.responseEnd > 0) {
                        return entry;
                    }
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            // Return whatever we have after retries, even if incomplete
            const entries = performance.getEntriesByName(url, "resource");
            return entries.length > 0 ? entries[entries.length - 1] : null;
        }

        // Extract timing data from Resource Timing entry
        function extractTimingData(entry, url) {
            if (!entry) {
                return {
                    url,
                    error: "No Resource Timing entry found",
                    transferSize: null,
                    encodedBodySize: null,
                    decodedBodySize: null,
                    duration: null,
                    downloadTime: null,
                    deliveryType: null,
                    protocol: null,
                    contentEncoding: null
                };
            }

            return {
                url,
                transferSize: entry.transferSize,
                encodedBodySize: entry.encodedBodySize,
                decodedBodySize: entry.decodedBodySize,
                duration: entry.duration,
                downloadTime: entry.responseEnd - entry.responseStart,
                deliveryType: entry.deliveryType || (entry.transferSize === 0 && entry.encodedBodySize > 0 ? "cache" : "network"),
                protocol: entry.nextHopProtocol,
                contentEncoding: entry.contentEncoding || null
            };
        }

        // Action: init - verify cache is clean
        async function actionInit() {
            const baseUrlFull = buildUrl(CONFIG.baseUrl);
            const diffUrlFull = buildUrl(CONFIG.diffUrl);

            const baseEntries = performance.getEntriesByName(baseUrlFull, "resource");
            const diffEntries = performance.getEntriesByName(diffUrlFull, "resource");

            if (baseEntries.length > 0 || diffEntries.length > 0) {
                reportResult({
                    action: "init",
                    status: "error",
                    message: "Cache not clean - found existing Resource Timing entries",
                    baseEntriesCount: baseEntries.length,
                    diffEntriesCount: diffEntries.length
                });
                return;
            }

            reportResult({
                action: "init",
                status: "ok",
                message: "Cache is clean - no existing entries found"
            });
        }

        // Action: load_base - load base file and report timing
        async function actionLoadBase() {
            await loadResource(CONFIG.baseUrl, "base", "load_base");
        }

        // Action: load_diff - load diff file and report timing
        async function actionLoadDiff() {
            await loadResource(CONFIG.diffUrl, "diff", "load_diff");
        }

        // Shared function to load a resource and report timing
        async function loadResource(baseUrl, resourceType, actionName) {
            const url = buildUrl(baseUrl);
            performance.clearResourceTimings();

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                // Get Content-Length header for transfer size (compressed size on the wire)
                const contentLengthHeader = response.headers.get('Content-Length');
                const contentEncodingHeader = response.headers.get('Content-Encoding');
                
                // Consume response body fully using arrayBuffer to ensure complete download
                const body = await response.arrayBuffer();
                const decodedSize = body.byteLength;
                
                // Small delay to ensure performance timing entry is finalized
                await new Promise(resolve => setTimeout(resolve, 50));

                const entry = await getResourceTimingEntry(url);
                const timing = extractTimingData(entry, url);
                
                // Use Content-Length header as transferSize if Resource Timing doesn't provide it
                // (cross-origin requests without Timing-Allow-Origin will have transferSize=0)
                const transferSize = timing.transferSize > 0 
                    ? timing.transferSize 
                    : (contentLengthHeader ? parseInt(contentLengthHeader, 10) : null);
                
                // Use actual decoded body size if Resource Timing doesn't provide it
                const actualDecodedBodySize = timing.decodedBodySize > 0 
                    ? timing.decodedBodySize 
                    : decodedSize;
                
                // Use Content-Encoding header if Resource Timing doesn't provide contentEncoding
                const contentEncoding = timing.contentEncoding || contentEncodingHeader;

                reportResult({
                    action: actionName,
                    status: "ok",
                    resourceType,
                    httpStatus: response.status,
                    contentEncoding: contentEncoding,
                    url: timing.url,
                    transferSize: transferSize,
                    encodedBodySize: timing.encodedBodySize > 0 ? timing.encodedBodySize : transferSize,
                    decodedBodySize: actualDecodedBodySize,
                    duration: timing.duration,
                    downloadTime: timing.downloadTime,
                    deliveryType: timing.deliveryType,
                    protocol: timing.protocol
                });
            } catch (error) {
                reportResult({
                    action: actionName,
                    status: "error",
                    message: error.message,
                    url
                });
            }
        }

        // Parse query parameters and execute action
        async function main() {
            const params = new URLSearchParams(window.location.search);
            const action = params.get("action");

            // Allow overriding URLs via query params
            if (params.get("baseUrl")) {
                CONFIG.baseUrl = params.get("baseUrl");
            }
            if (params.get("diffUrl")) {
                CONFIG.diffUrl = params.get("diffUrl");
            }
            if (params.get("wscdt")) {
                CONFIG.wscdtParam = params.get("wscdt");
            }

            log(`Action: ${action || "none"}`, "info");
            log(`Base URL: ${CONFIG.baseUrl}`, "info");
            log(`Diff URL: ${CONFIG.diffUrl}`, "info");

            switch (action) {
                case "init":
                    await actionInit();
                    break;
                case "load_base":
                    await actionLoadBase();
                    break;
                case "load_diff":
                    await actionLoadDiff();
                    break;
                default:
                    reportResult({
                        action: action || "none",
                        status: "error",
                        message: "Unknown or missing action. Valid actions: init, load_base, load_diff"
                    });
            }
        }

        // Run on page load
        main().catch(error => {
            reportResult({
                action: "unknown",
                status: "error",
                message: `Unhandled error: ${error.message}`
            });
        });
    </script>
</body>
</html>
